window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pyCBEM", "modulename": "pyCBEM", "type": "module", "doc": "<p></p>\n"}, {"fullname": "pyCBEM.RGC_CBEM", "modulename": "pyCBEM.RGC_CBEM", "type": "module", "doc": "<p>Simple class to solve the Conductance-based encoding model for retinal ganglion cells in:\n    K. W. Latimer,  F. Rieke, &amp; J. W. Pillow (2019). Inferring synaptic inputs from spikes with a conductance-based neural encoding model.eLife 8 (2019): e47012.</p>\n\n<p>Requires Jax for computations.</p>\n\n<p>Copyright (c) 2022 Kenneth Latimer</p>\n"}, {"fullname": "pyCBEM.RGC_CBEM.getSimpleStimulusBasis", "modulename": "pyCBEM.RGC_CBEM", "qualname": "getSimpleStimulusBasis", "type": "function", "doc": "<p>A simple default basis to use for stimulus-dependent conductance filters made with a modified cardinal spline.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>binSize_ms:</strong>  time bin size in milliseconds</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (basis, time)</p>\n  \n  <p>basis: [BT_stim x P_stim] - Each column is a basis vector</p>\n  \n  <p>time:  [BT_stim] - Time (in milliseconds) of the rows of the basis</p>\n</blockquote>\n", "signature": "(binSize_ms: float) -> tuple[numpy.ndarray, numpy.ndarray]", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.getSimpleSpkHistBasis", "modulename": "pyCBEM.RGC_CBEM", "qualname": "getSimpleSpkHistBasis", "type": "function", "doc": "<p>A simple default basis to use for spike history filters made with a modified cardinal spline.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>binSize_ms:</strong>  time bin size in milliseconds</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (basis, time)</p>\n  \n  <p>basis: [BT_hspk x P_hspk] - Each column is a basis vector</p>\n  \n  <p>time:  [BT_stim] - Time (in milliseconds) of the rows of the basis</p>\n</blockquote>\n", "signature": "(binSize_ms: float) -> tuple[numpy.ndarray, numpy.ndarray]", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic", "type": "class", "doc": "<p>A basic implementation of the Conductance-based encoding model.\nThe model has three inputs: excitatory and inhibitory conductance (soft-rectified, affine function in the stimulus)\n                            a linear spike history (not conductance-based)\nThe 'setObservations' sets up the data: current stimulus and spike train.</p>\n"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.__init__", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.__init__", "type": "function", "doc": "<p>Initialize simple CBEM with one excitatory and one inhibitory conductance which share input.</p>\n\n<p>Note: bases are orthogonalized before fitting. Filter parameters will be in terms of the orthogonalized basis.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>binSize_ms:</strong>            time bin size in milliseconds</li>\n<li><strong>basis_conductance:</strong>     [BT_stim x P_stim], if None then getSimpleStimulusBasis(binSize_ms) -\nEach column is a basis function for the conductances (conductances share a basis).\nThe basis is assumed to be causal: basis_conductance[0,:] are the basis weights for the previous time bin.</li>\n<li><strong>basis_hspk:</strong>            [BT_hspk x P_hspk], if None then getSimpleSpkHistBasis(binSize_ms) -\nEach column is a basis function for the spike history.\nThe basis is assumed to be causal: basis_conductance[0,:] are the basis weights for the previous time bin.</li>\n</ul>\n", "signature": "(\n    self,\n    binSize_ms: float,\n    basis_conductance: numpy.ndarray = None,\n    basis_hspk: numpy.ndarray = None\n)", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.B_cond", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.B_cond", "type": "variable", "doc": "<p>jnp.ndarray: [(BT_stim + 1) x 2] - The conductance filters and baseline parameters.</p>\n"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.B_hspk", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.B_hspk", "type": "variable", "doc": "<p>jnp.ndarray: [BT_hspk x 1] - The spike history filter parameters.</p>\n"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.setObservations", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.setObservations", "type": "function", "doc": "<p>Initializes the stimulus and spike train observation for this neuron.\nThis assumes only one spike per bin is possible.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>Stimulus:</strong>          [T_stim x number of pixels] - Pixels are treated independently</li>\n<li><strong>spkTimes_bins:</strong>     List of the spike times in bins.</li>\n<li><strong>window:</strong>            The window of stimulus and spikes to fit. This input allows you to cut out the first \npart of the given spike train to avoid edge effects for spike history or stimulus.</li>\n</ul>\n", "signature": "(\n    self,\n    Stimulus: numpy.ndarray,\n    spkTimes_bins: list,\n    window: range\n) -> None", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getConductances", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getConductances", "type": "function", "doc": "<p>Computes the conductances given the conductance filter parameters for the current stimulus.\nThe conductance nonlinearity is a soft-rectifier.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B_cond:</strong>    [(P_stim + 1) x 2], if None then self.get_B_cond() -\nParameters of the two conductance filters as weights on the basis functions. First column is excitatory, second inhibitory.\nThe last entry is the basline term.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>gs  [T_stim x 2] - first column is excitatory conductance, second inhibitory</p>\n</blockquote>\n", "signature": "(\n    self,\n    B_cond: jax._src.numpy.ndarray.ndarray = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getVoltage", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getVoltage", "type": "function", "doc": "<p>Computes the voltage given the conductance parameters for the set stimulus.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B_cond:</strong>   [(P_stim + 1) x 2], if None then  self.get_B_cond() -\nParameters of the two conductance filters as weights on the basis function. First column is excitatory, second inhibitory.\nThe last entry is the basline term.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>V [T_stim] - the solved voltage in millivolts</p>\n</blockquote>\n", "signature": "(\n    self,\n    B_cond: jax._src.numpy.ndarray.ndarray = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.firingRateNonlinearity", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.firingRateNonlinearity", "type": "function", "doc": "<p>Computes the firing rate nonlinearity on the given total voltage.\nThe nonlinearity is alpha * softplus((V_tot - mu)/beta)</p>\n\n<ul>\n<li>self.frNonlinearity holds the parameters alpha, beta, and mu</li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>V_tot:</strong>     [T] - The total voltage terms.\nTotal voltage is the membrane potential from the membrane potential equation plus spike history terms.</li>\n</ul>\n\n<p>Returns: <br />\n  spikeRate [T] - the firing rate for each term in V_tot</p>\n", "signature": "(\n    self,\n    V_tot: jax._src.numpy.ndarray.ndarray\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getSpikeHistory", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getSpikeHistory", "type": "function", "doc": "<p>Computes the spike history given the parameters for the set spike train. (A simple linear function)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B_hspk:</strong>    [P_hspk x 1], if None then self.get_B_hspk() - Parameters of the spike history filter as weights on the basis functions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>hspk  [T_stim] - the linear spike history</p>\n</blockquote>\n", "signature": "(\n    self,\n    B_hspk: jax._src.numpy.ndarray.ndarray = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getSpikeRate", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getSpikeRate", "type": "function", "doc": "<p>Computes the spike rate at each time given the conductance and spike history parameters for the set stimulus &amp; spike history.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B_cond:</strong>    [(P_stim + 1) x 2], if None then  self.get_B_cond() - Parameters of the two conductance filters as weights on the basis function. First column is excitatory, second inhibitory.</li>\n<li><strong>B_hspk:</strong>    [P_hspk x 1], if None then  self.get_B_hspk() - Parameters of the spike history filter as weights on the basis functions.</li>\n</ul>\n\n<p>Returns <br />\n  spikeRate [T_stim] - the firing rate in each bin in units of spikes/sec</p>\n", "signature": "(\n    self,\n    B_cond: jax._src.numpy.ndarray.ndarray = None,\n    B_hspk: jax._src.numpy.ndarray.ndarray = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getLogLike", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getLogLike", "type": "function", "doc": "<p>Computes the log likelihood at each time bin given the conductance and spike history parameters for the set stimulus &amp; spike history.\nThis function uses a truncated Poisson likelihood. That is, Poisson(0 | rate) for bins without a spike and\n                                                         (1-Poisson(0 | rate)) for bins with a spike.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B_cond:</strong>    [(P_stim + 1) x 2], if None then self.get_B_cond() - Parameters of the two conductance filters as weights on the basis function. First column is excitatory, second inhibitory.</li>\n<li><strong>B_hspk:</strong>    [P_hspk x 1], if None then  self.get_B_hspk() - Parameters of the spike history filter as weights on the basis functions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ll_bins [T_stim] - the log likelihood of the observation (a spike or no spike) at each bin.</p>\n</blockquote>\n", "signature": "(\n    self,\n    B_cond: jax._src.numpy.ndarray.ndarray = None,\n    B_hspk: jax._src.numpy.ndarray.ndarray = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.randomizeParameters", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.randomizeParameters", "type": "function", "doc": "<p>Sets the parameters of the model using i.i.d. normal draws.\nAll filter weights are drawn with mean 0.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>offset_term_mean:</strong>  Mean of the baseline term of the conductances. This probably should be positive.</li>\n<li><strong>std_cond:</strong>          Standard deviation of the conductance parameters.</li>\n<li><strong>std_lin:</strong>           Standard deviation of the spike history parameters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (B_cond, B_hspk)</p>\n  \n  <p>B_cond: [(P_stim + 1) x 2] - Parameters of the two conductance filters as weights on the basis function. First column is excitatory, second inhibitory.</p>\n  \n  <p>B_hspk:  [P_hspk x 1] - Parameters of the spike history filter as weights on the basis functions.</p>\n</blockquote>\n", "signature": "(\n    self,\n    offset_term_mean: float = 10,\n    std_cond: float = 1,\n    std_lin: float = 1\n) -> None", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.vectorizeParameters", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.vectorizeParameters", "type": "function", "doc": "<p>Flatens the parameters into a vector for optimization.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B_cond:</strong>    [(P_stim + 1) x 2], if None then self.B_cond -\nParameters of the two conductance filters as weights on the basis function. First column is excitatory, second inhibitory.</li>\n<li><strong>B_hspk:</strong>    [P_hspk x 1], if None then self.B_hspk -\nParameters of the spike history filter as weights on the basis functions.\nThe last entry is the basline term.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>B [(P_stim + 1) * 2 + P_hspk] - Flattened B_cond and B_hspk</p>\n</blockquote>\n", "signature": "(\n    self,\n    B_cond: jax._src.numpy.ndarray.ndarray = None,\n    B_hspk: jax._src.numpy.ndarray.ndarray = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.devectorizeParameters", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.devectorizeParameters", "type": "function", "doc": "<p>Takens in a vector of the parameters and returns them in more convenient separate, matrix forms.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B:</strong>   [(P_stim + 1) * 2 + P_hspk] - Flattened B_cond and B_hspk.\nThis should correspond to concatenate((B_cond.flatten(), B_hspk.flatten))</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (B_cond, B_hspk)</p>\n  \n  <p>B_cond: [(P_stim + 1) x 2] - \n        Parameters of the two conductance filters as weights on the basis function. First column is excitatory, second inhibitory.</p>\n  \n  <p>B_hspk:  [P_hspk x 1] - \n        Parameters of the spike history filter as weights on the basis functions.\n        The last entry is the basline term.</p>\n</blockquote>\n", "signature": "(\n    self,\n    B: jax._src.numpy.ndarray.ndarray\n) -> tuple[jax._src.numpy.ndarray.ndarray, jax._src.numpy.ndarray.ndarray]", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.setParametersFromVector", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.setParametersFromVector", "type": "function", "doc": "<p>Sets the current parameters from a vectorized form.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B:</strong>     [(P_stim + 1) * 2 + P_hspk] - Flattened B_cond and B_hspk.\nThis should correspond to concatenate((B_cond.flatten(), B_hspk.flatten))</li>\n</ul>\n", "signature": "(self, B: jax._src.numpy.ndarray.ndarray) -> None", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.vectorizedNegLogLike", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.vectorizedNegLogLike", "type": "function", "doc": "<p>Computes the negative log likelihood for the set stimulus and spike train.\nTakes in the parameters in a vectorized form for use with optimizers.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B:</strong>     [(P_stim + 1) * 2 + P_hspk] - Flattened B_cond and B_hspk.\nThis should correspond to concatenate((B_cond.flatten(), B_hspk.flatten))</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>nll [1] - The total negative log likelihood for the setup stimulus.</p>\n</blockquote>\n", "signature": "(\n    self,\n    B: jax._src.numpy.ndarray.ndarray\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.vectorizedPenalizedNegLogLike", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.vectorizedPenalizedNegLogLike", "type": "function", "doc": "<p>Computes the penalized negative log likelihood for the set stimulus and spike train.\nTakes in the parameters in a vectorized form for use with optimizers.\nThe penalty terms are the weighted squared norms of the conductance filters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>B:</strong>  [(P_stim + 1) * 2 + P_hspk] - Flattened B_cond and B_hspk.\nThis should correspond to concatenate((B_cond.flatten(), B_hspk.flatten))</li>\n<li><strong>conductance_penalty:</strong>   [2] -\nThe weights of the penalty on the squared norms of the filter weights.\nThe first term is for the excitatory and the second for the inhibitory.\nThe baseline conductance terms do not contribute to this penalty.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>nll [1] - The total negative log likelihood for the setup stimulus plus the penalties.</p>\n</blockquote>\n", "signature": "(\n    self,\n    B: jax._src.numpy.ndarray.ndarray,\n    conductance_penalty: list = [1, 0.2]\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getConductanceFilter", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getConductanceFilter", "type": "function", "doc": "<p>Gets the full conductance filter (basis times weights) for one of the conductance filters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cc:</strong>  Index of the conductance filter to return. 0 is excitatory, 1 is inhibitory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>k_stim [BT_stim x N_pixels] - The filter for each pixel.</p>\n</blockquote>\n", "signature": "(self, cc: int) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.getSpikeHistoryFilter", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.getSpikeHistoryFilter", "type": "function", "doc": "<p>Gets the full spike history filter (basis times weights).</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>h_spk [BT_hspk x 1] - The full spike history filter.</p>\n</blockquote>\n", "signature": "(self) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.RGC_CBEM.CBEM_basic.simulateSpikeTrains", "modulename": "pyCBEM.RGC_CBEM", "qualname": "CBEM_basic.simulateSpikeTrains", "type": "function", "doc": "<p>Simulates a set of spike trains with the currently set stimulus. This can be really slow!\nThis function requires an initial set of spikes to avoid dealing with edge effects of the spike history filter.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>Y_init:</strong>   [T_0 x (N or 1)] - A matrix of ones and zerosThe initial spike trains. T_0 should be less than T_stim</li>\n<li><strong>N:</strong>        (positive integer) - The number of simulations: only use this if Y_init.shape[1] == 1 and you want more than one simulation.\nIf N &gt; 1 and Y_init.shape[1] == 1, it uses the same initial spike train for all simulations.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>sps [T_stim x N] - A matrix of spikes for each of the N simulations. Spikes are either 1 or 0.</p>\n</blockquote>\n", "signature": "(\n    self,\n    Y_init: numpy.ndarray,\n    N: int = None\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.utils", "modulename": "pyCBEM.utils", "type": "module", "doc": "<p>Utility functions for working with the Conductance-based encoding model for retinal ganglion cells in:\n    K. W. Latimer,  F. Rieke, &amp; J. W. Pillow (2019). Inferring synaptic inputs from spikes with a conductance-based neural encoding model.eLife 8 (2019): e47012.</p>\n\n<p>Requires Jax for computations.</p>\n\n<p>Copyright (c) 2022 Kenneth Latimer</p>\n"}, {"fullname": "pyCBEM.utils.solveVoltage_tridiag", "modulename": "pyCBEM.utils", "qualname": "solveVoltage_tridiag", "type": "variable", "doc": "<p></p>\n", "default_value": " = <jax._src.custom_derivatives.custom_vjp object>"}, {"fullname": "pyCBEM.utils.solveVoltage_tridiag_fwd", "modulename": "pyCBEM.utils", "qualname": "solveVoltage_tridiag_fwd", "type": "function", "doc": "<p>The Jax custom vjp forward function for solveVoltage_tridiag.</p>\n", "signature": "(M, C)", "funcdef": "def"}, {"fullname": "pyCBEM.utils.solveVoltage_tridiag_bwd", "modulename": "pyCBEM.utils", "qualname": "solveVoltage_tridiag_bwd", "type": "function", "doc": "<p>The Jax custom vjp backward function for solveVoltage_tridiag.</p>\n", "signature": "(res, g)", "funcdef": "def"}, {"fullname": "pyCBEM.utils.getVoltage", "modulename": "pyCBEM.utils", "qualname": "getVoltage", "type": "function", "doc": "<p>Computes the voltage given the synaptic and leak conductances.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>gs:</strong>           [T x C] - Each column is the conductance value over time.</li>\n<li><strong>E_s:</strong>          [C] - Reversal potential for each conductance,</li>\n<li><strong>g_l:</strong>          Leak conductance.</li>\n<li><strong>E_l:</strong>          Leak reveral potential.</li>\n<li><strong>V_0:</strong>          Initial voltage (mV)</li>\n<li><strong>binSize_ms:</strong>   Time bin size in milliseconds.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>V [T] - Vector of the solved voltages (in mV).</p>\n</blockquote>\n", "signature": "(\n    gs: jax._src.numpy.ndarray.ndarray,\n    E_s: jax._src.numpy.ndarray.ndarray,\n    g_l: float,\n    E_l: float,\n    V_0: float,\n    binSize_ms: float\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.utils.ModifiedCardinalSpline", "modulename": "pyCBEM.utils", "qualname": "ModifiedCardinalSpline", "type": "function", "doc": "<p>Modified Cardinal Spline basis functions proposed by\nSarmashghi, M., Jadhav, S. P., &amp; Eden, U. (2021). Efficient Spline Regression for Neural Spiking Data. bioRxiv.</p>\n\n<h6 id=\"modified-by-kenneth-latimer-from-repository\">Modified by Kenneth Latimer from Repository</h6>\n\n<blockquote>\n  <p>https://github.com/MehradSm/Modified-Spline-Regression\n  by Mehrad Sarmashghi</p>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>window_end:</strong>       Last time point (in ms)</li>\n<li><strong>c_pt:</strong>             Locations of the knots.</li>\n<li><strong>window_start:</strong>     First time point (in ms)</li>\n<li><strong>s:</strong>                Tension parameter</li>\n<li><strong>binSize_ms:</strong>       Time bin size in milliseconds</li>\n<li><strong>zero_first:</strong>       Whether to set the end point at c_pt[0 ] to 0's (removes basis)</li>\n<li><strong>zero_last:</strong>        Whether to set the end point at c_pt[-1] to 0's (removes basis)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (basis, time)</p>\n  \n  <p>basis: [BT_stim x P_stim] - Each column is a basis vector</p>\n  \n  <p>time:  [BT_stim] - Time (in milliseconds) of the rows of the basis</p>\n</blockquote>\n", "signature": "(\n    window_end: float,\n    c_pt: list,\n    window_start: float = None,\n    s: float = 0.5,\n    binSize_ms: float = 1,\n    zero_first: bool = False,\n    zero_last: bool = False\n) -> tuple[numpy.ndarray, numpy.ndarray]", "funcdef": "def"}, {"fullname": "pyCBEM.utils.convolveStimulusWithBasis", "modulename": "pyCBEM.utils", "qualname": "convolveStimulusWithBasis", "type": "function", "doc": "<p>Convolves a basis set with a set of input vectors.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>stimulus:</strong>     [T x N_pixels] - Each column is treated as a separate pixel.</li>\n<li><strong>basis:</strong>        [BT x P] - Each column is a basis function.</li>\n<li><strong>add_ones:</strong>     If True, adds an extra column of ones at the end of the basis convolution for an offset term.</li>\n<li><strong>is_balanced:</strong>  If basis is balanced so that the convolution can be called with mode=\"same\".\nIf False, the basis is assumed to be causal.</li>\n</ul>\n\n<p>Returns: \n  X [T x (N_pixels*P + add_ones)] - the columns X[:, 0:P] contain stimulus[:,0] convolved with the basis (repeats for each pixel)\n  Last column is ones if add_ones == True.</p>\n", "signature": "(\n    stimulus: numpy.ndarray,\n    basis: numpy.ndarray,\n    add_ones: bool = True,\n    is_balanced: bool = False\n) -> jax._src.numpy.ndarray.ndarray", "funcdef": "def"}, {"fullname": "pyCBEM.utils.convolveSpksWithBasis", "modulename": "pyCBEM.utils", "qualname": "convolveSpksWithBasis", "type": "function", "doc": "<p>Convolves a basis set with a set of spike times.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>spk times:</strong>    Spike times in bins</li>\n<li><strong>basis:</strong>        [BT x P] - Each column is a basis function.</li>\n<li><strong>add_ones:</strong>     If True, adds an extra column of ones at the end of the basis convolution for an offset term.</li>\n<li><strong>is_balanced:</strong>  If basis is balanced so that the convolution can be called with mode=\"same\".\nIf False, the basis is assumed to be causal.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (X, Y)</p>\n  \n  <p>X: [T x (N_pixels*P + add_ones)] - the columns X[:, 0:P] contain Y convolved with the basis (repeats for each pixel)\n       Last column is ones if add_ones == True.</p>\n  \n  <p>Y: [T] - Vectorized spike time vector. Bins are 0's or 1's to indicate whether a spike happened or not in each bin.</p>\n</blockquote>\n", "signature": "(\n    spkTimes_bins: list,\n    basis: numpy.ndarray,\n    T_max: int,\n    add_ones: bool = False,\n    is_balanced: bool = False\n) -> tuple[jax._src.numpy.ndarray.ndarray, numpy.ndarray]", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();